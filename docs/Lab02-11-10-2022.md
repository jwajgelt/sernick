### Lexer


1. NFA -> DFA -> Minimalizacja
2. Pochodne Brzozowskiego

Wybralismy pochodne :P


#### Regexy i pochodne
Jak bedziemy opisywac regexy?

Regex:
- atom (pojedyncza litera) -- Char
- union (mamy do wyboru sume binarna lub sume N-arna gdzie N moze byc 0, i wtedy
  nie musimy pisac pustego jezyka i mamy latwiejsza normalizacje)
  `children: Enumerable<Regex>`
- konkatenacja: tylko binarna lub N-arna
  N-arna
- star (child: Regex)

Najłatwiej to ująć klasą bazową (abstrakcyjną?) z klasami pochodnymi czyli
Base `class Regex` oraz `AtomRegex, UnionRegex, ConcatRegex, StarRegex`


Co jest do zrobienia?
**AI - action item

* Normalizacja od razu, przy konstrukcji (factory methods, nie konstruktor)
Czyli metody statyczne w klasie bazowej
  AI -- najpierw zamockowane zeby dalo sie innym korzystac
  AI -- potem "prawdziwe"

* Regex: IEquatable<Regex> (naturalny sposob w C# zeby powiedziec ze cos jest porownywalne)
  AI: Implementacja strukturalna IEquatable<Regex>

* containsEpsilon(): bool -- abstrakcyjna w Regex i do zaimplementowania w podklasach

* derivative(atom: Char): Regex -- abstrakcyjna w Regex i do zaimpl. w podklasach



#### Automat

IDfa:
* Stan startowy: jak to zrobic?
  1. Int
  2. IDFAState (interfejs)
  3. Idfa<TState> -- symulacja za pomoca generykow
  Wybralismy opcje 3 -- automat podaje jako generyk typ stanu
* isAccepting(state): bool
* isDead(state): bool
* transition(Tstate, Char): TState
* kazdy automat musi miec stan martwy (zwracamy go z transition() jesli nie ma przejscia)


#### Lexer
Na wejsciu dostaje ciag znakow,na wyjsciu wypluwa ciag tokenow
token = slowo kluczowe | identyfikator | liczba | nawias | cos jeszcze


ILexer<TCategory, TState>
* process(...): IEnumerable<Token<TCategory>>
* Lexer(ReadonlyDictionary<TCategory, IDfa<TState>>)



Token<TCategory>:
* text: string
* category: TCategory
* start: ILocation
* end: ILocation


ILocation
* toString(): String // zwraca opis dla uzytkownika

IInput : IEnumerable<Char>
* currentLocation: Ilocation { get; }
* moveTo(ILocation): void;


#### Gramatyka

Faktyczne kategorie tokenow w jezyku

* parser String to Regex
